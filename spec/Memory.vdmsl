module Memory
imports from AST all
exports all
definitions
types
     Address = nat1;

values
     ADDRESS_ERROR = <ADDRESS_ERROR>;
     TIME_ERROR = <TIME_ERROR>;

state Memory of
    vals : map Address to real
    next : map Address to real
    delta : map Address to real
    nextAvailableSlot : Address
    animats : map AST`Identifier to set of Address
    newBorns : map AST`Identifier to set of Address
    deads : map AST`Identifier to set of Address
    storage : seq of (map Address to real)
    ticks : nat
init s ==
    s = mk_Memory({|->}, {|->}, {|->}, 1, {|->}, {|->}, {|->}, [], 0)
end

operations
    allocate : AST`Identifier * nat1 ==> Address
    allocate(identifier, size) ==
        let address : Address = nextAvailableSlot
        in
            (nextAvailableSlot := nextAvailableSlot + size;
            newBorns(identifier)
                := (if identifier in set dom newBorns then newBorns(identifier) else {})
                union {address};
            return address);
    
    deallocate : AST`Identifier * Address ==> ()
    deallocate(identifier, address) ==
        deads(identifier)
            := (if identifier in set dom deads then deads(identifier) else {})
            union {address};
    
    read : Address ==> real
    read(address) ==
        if address in set dom vals then return vals(address) else exit ADDRESS_ERROR;
    
    write : Address * real ==> ()
    write(address, data) ==
        if address in set dom next then next(address) := data else exit ADDRESS_ERROR;
    
    writeDelta : Address * real ==> ()
    writeDelta(address, data) ==
        if
            address in set dom delta
        then
            delta(address) := delta(address) + data
        else
            exit ADDRESS_ERROR;
    
    setTime : nat1 ==> ()
    setTime(t) ==
        (if t = len storage + 1 then store();
        if t > len storage + 1 then exit TIME_ERROR;
        load(t);
        ticks := t;
        return );
    
    getTime : () ==> nat
    getTime() == return ticks;
    
    tick : () ==> ()
    tick() == setTime(getTime() + 1);
    
    store : () ==> ()
    store() ==
        (storage
            := storage ^ [{a |-> next(a) + delta(a) | a in set dom next}];
        animats
            := {animat
            |-> (animats(animat)
                \ (if animat in set dom deads then deads(animat) else {}))
            union (if animat in set dom newBorns then newBorns(animat) else {})
            | animat in set dom animats});
    
    load : nat1 ==> ()
    load(t) ==
        (vals := storage(t);
        next := vals;
        delta := {a |-> 0 | a in set dom vals};
        newBorns := {|->};
        deads := {|->});

end Memory
