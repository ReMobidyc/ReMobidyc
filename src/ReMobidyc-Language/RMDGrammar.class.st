Class {
	#name : #RMDGrammar,
	#superclass : #PP2CompositeNode,
	#instVars : [
		'_expression',
		'_actionDefinition',
		'_agentIdentifier',
		'_agentReference',
		'_animatDefinition',
		'_condition',
		'_csvColumnName',
		'_csvTimeColumnName',
		'_guardedChoice',
		'_identifier',
		'_literal',
		'_patchDefinition',
		'_taskDefinition',
		'_unit',
		'_worldDefinition'
	],
	#classVars : [
		'Builtins',
		'Current',
		'Keywords'
	],
	#category : #'ReMobidyc-Language-Parser'
}

{ #category : #'accessing method dictionary' }
RMDGrammar class >> addSelectorSilently: selector withMethod: compiledMethod [
	Keywords := nil.
	Builtins := nil.
	Current := nil.
	^ super addSelectorSilently: selector withMethod: compiledMethod
]

{ #category : #accessing }
RMDGrammar class >> current [

	^ Current ifNil: [ Current := self new ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> _actionDefinition [

	^ self actionDefinitionHeaderLine , self whenClause optional
	  , self withDirectiveClause optional
	  , self actionDefinitionAttributePart optional
	  , self whereClause optional
	  , '.' asPParser trimBlanks , #newline asPParser trimBlanks optional
	  ==> [ :array | 
		  self actionDefinitionNodeClass
			  name: array first first
			  object: array first second
			  guard: array second
			  lifeDirectives: (array third ifNil: [ Array new ])
			  attributeDefinitions: (array fourth ifNil: [ Array new ])
			  utilityDefinitions: (array fifth ifNil: [ Array new ]) ]
]

{ #category : #'parsers-atoms' }
RMDGrammar >> _agentIdentifier [
	^ (#letter asPParser
		, (#letter asPParser / #digit asPParser / $_ asPParser) star)
		flatten trimBlanks
		==> [ :name | 
			(self keywords includes: name)
				ifTrue: [ PP2Failure message: name , ' is a reserved word.' ]
				ifFalse: [ name first isUppercase
						ifTrue: [ name ]
						ifFalse: [ PP2Failure
								message: 'An agent name must start with a uppercase letter.' ] ] ]
]

{ #category : #'parsers-atoms' }
RMDGrammar >> _agentReference [

	^ ('my' asPParser , #space asPParser) trimBlanks ==> [ :str | nil ]
	  /
	  (('new' asPParser , #space asPParser) trimBlanks
	   ==> [ :str | #new ])
	  / (_identifier , '''s ' asPParser trimBlanks ==> #first)
]

{ #category : #'parsers-definitions' }
RMDGrammar >> _animatDefinition [

	^ self animatHeader , self withAttributeClause optional
	  , self whereClause optional , '.' asPParser trimBlanks
	  , #newline asPParser trimBlanks optional ==> [ :penta | 
	  self animatDefinitionNodeClass
		  identifier: penta first first
		  species: penta first second
		  attributeDeclarations: (penta second ifNil: [ Array new ])
		  utilityDefinitions: (penta third ifNil: [ Array new ]) ]
]

{ #category : #'parsers-conditions' }
RMDGrammar >> _condition [

	^ self cond3
]

{ #category : #'parsers-files' }
RMDGrammar >> _csvColumnName [

	^ self csvTimeColumnName
	  / (_identifier , self type , self interpolation optional)
]

{ #category : #'parsers-files' }
RMDGrammar >> _csvTimeColumnName [

	^ 'time' asPParser trimBlanks , self type , self cycle optional
]

{ #category : #'parsers-expressions' }
RMDGrammar >> _expression [

	^ self guardedChoice
]

{ #category : #'parsers-expressions' }
RMDGrammar >> _guardedChoice [
	^ (self expr6 separatedBy: self guard)
		==> [ :array | 
			array size = 1
				ifTrue: [ array first ]
				ifFalse: [ self guardedChoiceNodeClass
						from:
							(((1 to: array size - 1 by: 2)
								collect: [ :index | (array at: index + 1) -> (array at: index) ])
								copyWith: true -> array last) ] ]
]

{ #category : #'parsers-atoms' }
RMDGrammar >> _identifier [
	^ (#letter asPParser
		, (#letter asPParser / #digit asPParser / $_ asPParser) star)
		flatten
		==> [ :name | 
			(self keywords includes: name)
				ifTrue: [ PP2Failure message: name , ' is a reserved word.' ]
				ifFalse: [ name first isLowercase
						ifTrue: [ name ]
						ifFalse: [ PP2Failure
								message: 'An identifier must start with a lowercase letter.' ] ] ]
]

{ #category : #'parsers-atoms' }
RMDGrammar >> _literal [

	^ self numberString , self type optional ==> [ :pair | 
	  self literalNodeClass
		  literal: pair first
		  unit: (pair second ifNil: [ RMDUnit noDimension ]) ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> _patchDefinition [

	^ 'Patch' asPParser , self withAttributeClause optional
	  , self whereClause optional , '.' asPParser trimBlanks
	  , #newline asPParser trimBlanks optional ==> [ :penta | 
	  self patchDefinitionNodeClass
		  attributeDeclarations: (penta second ifNil: [ Array new ])
		  utilityDefinitions: (penta third ifNil: [ Array new ]) ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> _taskDefinition [

	^ self taskDefinitionHeader , self disabled optional
	  , self whenClause optional
	  , (#newline asPParser trimBlanks , 'where' asPParser trimBlanks
		   , #newline asPParser trimBlanks
		   , (self parameterInstantiation onlySeparatedBy:
				    #newline asPParser trimBlanks) ==> #fourth) optional
	  ,
	  ($. asPParser trimBlanks , #newline asPParser trimBlanks optional)
	  ==> [ :quad |
		  self bindNodeClass
			  subjectIdentifier: quad first first
			  verbIdentifier: quad first second
			  objectIdentifier: quad first fourth
			  actionIdentifier: quad first sixth
			  nearest: quad first third
			  within: quad first fifth
			  enabled: quad second isNil
			  guard: quad third
			  parameterInstantiations: (quad fourth ifNil: [ Array new ]) ]
]

{ #category : #'parsers-units' }
RMDGrammar >> _unit [
	^ (self unitTerm
		, (('/' asPParser trimBlanks , self unitTerm) ==> #second) optional)
		==> [ :pair | 
			pair second
				ifNotNil: [ pair first / pair second ]
				ifNil: [ pair first ] ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> _worldDefinition [

	^ 'World' asPParser , self withAttributeClause optional
	  , self whereClause optional , '.' asPParser trimBlanks
	  , #newline asPParser trimBlanks optional ==> [ :penta |
	  self worldDefinitionNodeClass
		  attributeDeclarations: (penta second ifNil: [ Array new ])
		  utilityDefinitions: (penta third ifNil: [ Array new ]) ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> actionDefinition [

	^ _actionDefinition
]

{ #category : #'parsers-definitions' }
RMDGrammar >> actionDefinitionAttributePart [

	^ #newline asPParser trimBlanks optional
	  , (self attributeDefinition onlySeparatedBy:
			   #newline asPParser trimBlanks) ==> #second
]

{ #category : #'parsers-definitions' }
RMDGrammar >> actionDefinitionHeaderLine [

	^ 'to' asPParser trimBlanks , _identifier trimBlanks
	  , _agentIdentifier optional , 'is' asPParser trimBlanks
	  ==> [ :array | 
		  { 
			  array second.
			  array third } ]
]

{ #category : #'class access' }
RMDGrammar >> actionDefinitionNodeClass [
	^ RMDActionDefinitionNode 
]

{ #category : #'parsers-definitions' }
RMDGrammar >> actionIdentifier [

	^ _identifier
]

{ #category : #'parsers-files' }
RMDGrammar >> actionsFile [

	^ self actionDefinition star
	  ==> [ :actions | self actionsFileNodeClass actions: actions ]
]

{ #category : #'class access' }
RMDGrammar >> actionsFileNodeClass [

	^ RMDActionsFileNode
]

{ #category : #'class access' }
RMDGrammar >> additionNodeClass [
	^ RMDAdditionNode
]

{ #category : #'parsers-definitions' }
RMDGrammar >> agentDefinition [

	^ self worldDefinition / self patchDefinition / self animatDefinition
]

{ #category : #'parsers-atoms' }
RMDGrammar >> agentDirective [

	^ self numberOfIndividualsInPatchDirective
	  / self numberOfIndividualsInWorldDirective
	  / self numberOfIndividualsInRadiusDirective
	  / self densityOfIndividualsInPatchDirective
	  / self densityOfIndividualsInWorldDirective
	  / self densityOfIndividualsInRadiusDirective
	  / self directionOfGradientDirective / self distanceDirective
	  / self directionDirective / self timeDirective
	  / self lengthDirective / self areaDirective
]

{ #category : #'parsers-atoms' }
RMDGrammar >> agentIdentifier [

	^ _agentIdentifier
]

{ #category : #'parsers-atoms' }
RMDGrammar >> agentReference [

	^ _agentReference
]

{ #category : #'parsers-files' }
RMDGrammar >> agentsFile [

	^ self agentDefinition star
	  ==> [ :agents | self agentsFileNodeClass agents: agents ]
]

{ #category : #'class access' }
RMDGrammar >> agentsFileNodeClass [

	^ RMDAgentsFileNode
]

{ #category : #units }
RMDGrammar >> allUnits [
	^ Dictionary new
		addAll: self timeUnits;
		addAll: self lengthUnits;
		addAll: self weightUnits;
		addAll: self energyUnits;
		addAll: self temperatureUnits;
		yourself
]

{ #category : #'parsers-definitions' }
RMDGrammar >> animatDefinition [

	^ _animatDefinition
]

{ #category : #'class access' }
RMDGrammar >> animatDefinitionNodeClass [
	^ RMDAnimatDefinitionNode
]

{ #category : #'parsers-visualizations' }
RMDGrammar >> animatDotRenderer [

	^ self agentIdentifier , '->' asPParser trimBlanks , self nat
	  , 'pixels' asPParser trimBlanks , self color
	  , 'dot' asPParser trimBlanks , '.' asPParser trimBlanks
	  , #newline asPParser trimBlanks optional ==> [ :array | 
	  RMDAnimatDotRenderer
		  on: (array at: 1)
		  shapeSize: (array at: 3)
		  color: (array at: 5) ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> animatHeader [

	^ _agentIdentifier , 'is' asPParser trimBlanks
	  , _agentIdentifier trimBlanks ==> [ :triple | 
	  { 
		  triple first.
		  triple third } ]
]

{ #category : #'parsers-visualizations' }
RMDGrammar >> animatIconRenderer [

	^ self agentIdentifier , '->' asPParser trimBlanks , $" asPParser
	  ,
	  ('\"' asPParser / ($" asPParser not , #any asPParser)) star flatten
	  , $" asPParser , self decimalString trimBlanks
	  , 'x ' asPParser trimBlanks , 'icon' asPParser trimBlanks
	  , '.' asPParser trimBlanks , #newline asPParser trimBlanks optional
	  ==> [ :array | 
		  | animat icon scale |
		  animat := array at: 1.
		  icon := (array at: 4) copyReplaceAll: '\"' with: '"'.
		  scale := (array at: 6) asNumber.
		  RMDAnimatIconRenderer on: animat iconName: icon scale: scale ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> animatInitializer [

	^ #digit asPParser plus flatten trimBlanks , _agentIdentifier
	  , ('with' asPParser trimBlanks , #newline asPParser trimBlanks
		   , (self attributeInitializer onlySeparatedBy:
				    #newline asPParser trimBlanks) ==> #third) optional
	  , self whereClause optional ==> [ :quad | 
	  self animatInitializerNodeClass
		  population: quad first asInteger
		  animat: quad second
		  attributeInitializers: (quad third ifNil: [ Array new ])
		  utilityDefinitions: (quad fourth ifNil: [ Array new ]) ]
]

{ #category : #'class access' }
RMDGrammar >> animatInitializerNodeClass [
	^ RMDAnimatInitializerNode
]

{ #category : #'parsers-visualizations' }
RMDGrammar >> animatRectangleRenderer [

	^ self agentIdentifier , '->' asPParser trimBlanks , self nat
	  , 'pixels' asPParser trimBlanks , self color
	  , 'rectangle' asPParser trimBlanks , '.' asPParser trimBlanks
	  , #newline asPParser trimBlanks optional ==> [ :array | 
	  RMDAnimatRectangleRenderer
		  on: (array at: 1)
		  shapeSize: (array at: 3)
		  color: (array at: 5) ]
]

{ #category : #'parsers-visualizations' }
RMDGrammar >> animatTriangleRenderer [

	^ self agentIdentifier , '->' asPParser trimBlanks , self nat
	  , 'pixels' asPParser trimBlanks , self color
	  , 'triangle' asPParser trimBlanks , '.' asPParser trimBlanks
	  , #newline asPParser trimBlanks optional ==> [ :array | 
	  RMDAnimatTriangleRenderer
		  on: (array at: 1)
		  shapeSize: (array at: 3)
		  color: (array at: 5) ]
]

{ #category : #'parsers-expressions' }
RMDGrammar >> apply [
	^ (_identifier , $( asPParser trimBlanks
		, (_expression onlySeparatedBy: $, asPParser trimBlanks)
		, $) asPParser trimBlanks)
		==>
			[ :quad | self applyNodeClass function: quad first expressions: quad third ]
]

{ #category : #'class access' }
RMDGrammar >> applyNodeClass [
	^ RMDApplyNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> areaDirective [

	^ ('area' asPParser , #blank asPParser plus , 'of' asPParser
	   , #blank asPParser plus , 'here' asPParser) trimBlanks
	  ==> [ :array | self areaDirectiveNodeClass new ]
]

{ #category : #'class access' }
RMDGrammar >> areaDirectiveNodeClass [

	^ RMDAreaDirectiveNode
]

{ #category : #'parsers-atoms' }
RMDGrammar >> assignableAttributeVariable [

	^ _agentReference , _identifier ==> [ :pair | 
	  self assignableAttributeVariableNodeClass
		  identifier: pair second
		  agent: pair first ] / (self the , _identifier ==> [ :pair | 
	   self assignableAttributeVariableNodeClass attributeVariable:
		   (self placeholderNodeClass identifier: pair second) ])
]

{ #category : #'class access' }
RMDGrammar >> assignableAttributeVariableNodeClass [
	^ RMDAssignableAttributeVariableNode
]

{ #category : #'parsers-atoms' }
RMDGrammar >> assignableDeltaAttributeVariable [

	^ _agentReference , self delta , _identifier ==> [ :triple | 
	  self assignableDeltaAttributeVariableNodeClass
		  identifier: triple third
		  agent: triple first ]
	  / (self the , self delta , _identifier ==> [ :triple | 
		   self assignableDeltaAttributeVariableNodeClass attributeVariable:
			   (self placeholderNodeClass identifier: triple third) ])
]

{ #category : #'class access' }
RMDGrammar >> assignableDeltaAttributeVariableNodeClass [
	^ RMDAssignableDeltaAttributeVariableNode
]

{ #category : #'parsers-atoms' }
RMDGrammar >> assignableDifferentialAttributeVariable [

	^ _agentReference , self differential , _identifier ==> [ :triple | 
	  self assignableDifferentialAttributeVariableNodeClass
		  identifier: triple third
		  agent: triple first ]
	  / (self the , self differential , _identifier ==> [ :triple | 
		   self assignableDifferentialAttributeVariableNodeClass 
			   attributeVariable:
			   (self placeholderNodeClass identifier: triple third) ])
]

{ #category : #'class access' }
RMDGrammar >> assignableDifferentialAttributeVariableNodeClass [
	^ RMDAssignableDifferentialAttributeVariableNode
]

{ #category : #'parsers-atoms' }
RMDGrammar >> assignableNewAttributeVariable [

	^ 'new' asPParser , #blank asPParser plus , _identifier
	  ==> [ :triple | 
		  self assignableAttributeVariableNodeClass attributeVariable:
			  (self newAttributeVariableNodeClass identifier: triple third) ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> assignableVariable [

	^ self assignableDifferentialAttributeVariable
	  / self assignableDeltaAttributeVariable
	  / self assignableAttributeVariable
]

{ #category : #'parsers-definitions' }
RMDGrammar >> attributeDeclaration [

	^ _identifier , self type
	  , ('=' asPParser trimBlanks , _expression ==> #second) optional
	  ==> [ :triple | 
		  self attributeDeclarationNodeClass
			  identifier: triple first
			  unit: triple second
			  initializerExpression: triple third ]
]

{ #category : #'class access' }
RMDGrammar >> attributeDeclarationNodeClass [
	^ RMDAttributeDeclarationNode
]

{ #category : #'parsers-definitions' }
RMDGrammar >> attributeDefinition [

	^ self assignableVariable , $' asPParser trimBlanks
	  , '=' asPParser trimBlanks , _guardedChoice ==> [ :quad | 
	  self attributeDefinitionNodeClass
		  variable: quad first
		  expression: quad fourth ]
]

{ #category : #'class access' }
RMDGrammar >> attributeDefinitionNodeClass [
	^ RMDAttributeDefinitionNode
]

{ #category : #'parsers-definitions' }
RMDGrammar >> attributeInitializer [

	^ _identifier
	  , ('=' asPParser trimBlanks , _expression ==> #second) optional
	  ==> [ :pair | 
		  self attributeInitializerNodeClass
			  identifier: pair first
			  expression: pair second ]
]

{ #category : #'class access' }
RMDGrammar >> attributeInitializerNodeClass [
	^ RMDAttributeInitializerNode
]

{ #category : #'parsers-atoms' }
RMDGrammar >> attributeVariable [
	^ (_agentReference , _identifier)
		==> [ :pair | 
			self attributeVariableNodeClass
				identifier: pair second
				agent: pair first ]
]

{ #category : #'class access' }
RMDGrammar >> attributeVariableNodeClass [
	^ RMDAttributeVariableNode
]

{ #category : #'parsers-visualizations' }
RMDGrammar >> backgroundColorRenderer [

	^ 'World' asPParser trimBlanks , '->' asPParser trimBlanks
	  , self color , '.' asPParser trimBlanks
	  , #newline asPParser trimBlanks optional
	  ==> [ :triple | RMDBackgroundColorRenderer color: triple third ]
]

{ #category : #'parsers-conditions' }
RMDGrammar >> binaryCombinatorFrom: anArray [
	| operator conds |
	anArray size = 1
		ifTrue: [ ^ anArray first ].
	operator := anArray second.
	2 to: anArray size by: 2 do: [ :index | 
		(anArray at: index) = operator
			ifFalse: [ ^ PP2Failure message: 'More than one kinds of logical operators.' ] ].
	conds := (1 to: anArray size by: 2)
		collect: [ :index | anArray at: index ].
	operator = 'and'
		ifTrue: [ ^ self conjunctionNodeClass conditions: conds ].
	operator = 'or'
		ifTrue: [ ^ self disjunctionNodeClass conditions: conds ].
	^ PP2Failure message: 'Unknown operator: ' , operator
]

{ #category : #'parsers-conditions' }
RMDGrammar >> binaryRelation [

	^ _expression , self binaryRelationOperator
	  , (_expression separatedBy: self binaryRelationOperator)
	  ==> [ :triple | 
		  self binaryRelationFrom:
			  (Array with: triple first with: triple second) , triple third ]
]

{ #category : #'parsers-conditions' }
RMDGrammar >> binaryRelationFrom: anArray [
	| operator expressions |
	anArray size < 3
		ifTrue: [ ^ PP2Failure message: 'No relational operator.' ].
	operator := anArray second.
	4 to: anArray size by: 2 do: [ :index | 
		operator = (anArray at: index)
			ifFalse:
				[ ^ PP2Failure message: 'More than one kinds of relational operators.' ] ].
	expressions := (1 to: anArray size by: 2)
		collect: [ :index | anArray at: index ].
	(operator = '/=' and: [ expressions size > 2 ])
		ifTrue: [ ^ PP2Failure message: '/= can not be cascaded.' ].
	^ (self binaryRelationNodeClassFor: operator)
		expressions: expressions
]

{ #category : #'parsers-conditions' }
RMDGrammar >> binaryRelationNodeClassFor: aString [
	aString = '='
		ifTrue: [ ^ RMDEqualityNode ].
	aString = '<='
		ifTrue: [ ^ RMDLessOrEqualNode ].
	aString = '<'
		ifTrue: [ ^ RMDLessThanNode ].
	aString = '>='
		ifTrue: [ ^ RMDGreaterOrEqualNode ].
	aString = '>'
		ifTrue: [ ^ RMDGreaterThanNode ].
	^ RMDNotEqualNode
]

{ #category : #'parsers-conditions' }
RMDGrammar >> binaryRelationOperator [

	^ ('=' asPParser / '/=' asPParser
	   / ($< asPParser , $= asPParser optional) flatten
	   / ($> asPParser , $= asPParser optional) flatten) trimBlanks
]

{ #category : #'class access' }
RMDGrammar >> bindNodeClass [
	^ RMDTaskDefinitionNode
]

{ #category : #'parsers-conditions' }
RMDGrammar >> chance [

	^ _expression , 'chance' asPParser trimBlanks
	  ==> [ :pair | self chanceNodeClass probability: pair first ]
]

{ #category : #'class access' }
RMDGrammar >> chanceNodeClass [

	^ RMDChanceNode
]

{ #category : #'parsers-visualizations' }
RMDGrammar >> color [

	^ #blank asPParser star , ((PP2ChoiceNode withAll:
		    (Color registeredColorNames collect: [ :n | 
			     n asString asPParser ])) ==> [ :name | Color named: name ]
	   / ($# asPParser , (#hex asPParser times: 6) flatten
		    ==> [ :pair | Color fromHexString: pair second ])) ==> #second
]

{ #category : #'parsers-conditions' }
RMDGrammar >> cond1 [

	^ $( asPParser trimBlanks , _condition , $) asPParser trimBlanks
	  ==> #second / self binaryRelation / self chance / self placeholder
]

{ #category : #'parsers-conditions' }
RMDGrammar >> cond2 [
	^ ('not' asPParser trimBlanks optional , self cond1)
		==> [ :pair | 
			pair first
				ifNotNil: [ self negationNodeClass condition: pair second ]
				ifNil: [ pair second ] ]
]

{ #category : #'parsers-conditions' }
RMDGrammar >> cond3 [
	^ (self cond2
		separatedBy: ('and' asPParser / 'or' asPParser) trimBlanks)
		==> [ :array | self binaryCombinatorFrom: array ]
]

{ #category : #'parsers-conditions' }
RMDGrammar >> condition [

	^ _condition
]

{ #category : #'class access' }
RMDGrammar >> conjunctionNodeClass [
	^ RMDConjunctionNode
]

{ #category : #'parsers-files' }
RMDGrammar >> csvColumnName [

	^ _csvColumnName
]

{ #category : #'parsers-files' }
RMDGrammar >> csvTimeColumnName [

	^ _csvTimeColumnName
]

{ #category : #'parsers-files' }
RMDGrammar >> cycle [

	^ 'cycle' asPParser trimBlanks , _literal trimBlanks ==> [ :pair |
	  | time |
	  time := pair second.
	  time unit isTime
		  ifTrue: [ time ]
		  ifFalse: [ PP2Failure message: 'cycle must be in time dimension' ] ]
]

{ #category : #'class access' }
RMDGrammar >> deUnitExpressionNodeClass [

	^ RMDDeUnitExpressionNode
]

{ #category : #'parsers-atoms' }
RMDGrammar >> decimalString [

	^ ($- asPParser optional , #digit asPParser plus
	   , ($. asPParser , #digit asPParser plus) optional) flatten
]

{ #category : #'parsers-definitions' }
RMDGrammar >> definition [
	^ self attributeDefinition
]

{ #category : #'parsers-atoms' }
RMDGrammar >> delta [
	^ ('delta ' asPParser / 'Δ' asPParser) trimBlanks
]

{ #category : #'class access' }
RMDGrammar >> deltaTimeDirectiveNodeClass [
	^ RMDDeltaTimeDirectiveNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> densityOfIndividualsInPatchDirective [

	^ 'density' asPParser trimLeft , #blank asPParser plus
	  , 'of' asPParser , #blank asPParser plus ==> [ :array | nil ]
	  , _agentIdentifier , 'here' asPParser trimBlanks ==> [ :triple | 
	  self densityOfIndividualsInPatchDirectiveNodeClass animatName:
		  triple second ]
]

{ #category : #'class access' }
RMDGrammar >> densityOfIndividualsInPatchDirectiveNodeClass [

	^ RMDDensityOfIndividualsInPatchDirectiveNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> densityOfIndividualsInRadiusDirective [

	^ 'density' asPParser trimLeft , #blank asPParser plus
	  , 'of' asPParser , #blank asPParser plus ==> [ :array | nil ]
	  , _agentIdentifier , ('in' asPParser trimBlanks , _expression
	   , 'radius' asPParser trimBlanks ==> #second) ==> [ :triple |
	  self densityOfIndividualsInRadiusDirectiveNodeClass
		  animatName: triple second
		  radius: triple third ]
]

{ #category : #'class access' }
RMDGrammar >> densityOfIndividualsInRadiusDirectiveNodeClass [

	^ RMDDensityOfIndividualsInRadiusDirectiveNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> densityOfIndividualsInWorldDirective [

	^ 'density' asPParser trimLeft , #blank asPParser plus
	  , 'of' asPParser , #blank asPParser plus ==> [ :array | nil ]
	  , _agentIdentifier
	  ,
		  ('in' asPParser , #blank asPParser plus
		   , 'world' asPParser trimBlanks ==> [ :array | nil ])
	  ==> [ :triple | 
		  self densityOfIndividualsInWorldDirectiveNodeClass animatName:
			  triple second ]
]

{ #category : #'class access' }
RMDGrammar >> densityOfIndividualsInWorldDirectiveNodeClass [

	^ RMDDensityOfIndividualsInWorldDirectiveNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> dieDirective [

	^ 'die' asPParser trimBlanks
	  ==> [ :die | self dieDirectiveNodeClass new ]
]

{ #category : #'class access' }
RMDGrammar >> dieDirectiveNodeClass [

	^ RMDDieDirectiveNode
]

{ #category : #'parsers-atoms' }
RMDGrammar >> differential [
	^ 'd/dt ' asPParser trimBlanks
]

{ #category : #'parsers-atoms' }
RMDGrammar >> differential2 [
	^ ('d2/dt2 ' asPParser / 'd^2/dt^2 ' asPParser) trimBlanks
]

{ #category : #'parsers-directives' }
RMDGrammar >> directionDirective [
	^ ('direction' asPParser trimBlanks , _identifier)
		==>
			[ :pair | self directionDirectiveNodeClass agent: pair second ]
]

{ #category : #'class access' }
RMDGrammar >> directionDirectiveNodeClass [
	^ RMDDirectionDirectiveNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> directionOfGradientDirective [

	^ 'direction' asPParser trimLeft , #blank asPParser plus
	  , ('neighbor''s' asPParser / 'neighbour''s' asPParser) trim
	  , _identifier ==> [ :pair | 
	  self directionOfGradientDirectiveNodeClass variable:
		  (RMDAttributeVariableNode identifier: pair fourth agent: 'here') ]
]

{ #category : #'class access' }
RMDGrammar >> directionOfGradientDirectiveNodeClass [
	^ RMDDirectionOfGradientDirectiveNode
]

{ #category : #'parsers-definitions' }
RMDGrammar >> disabled [

	^ 'disabled' asPParser trimBlanks
]

{ #category : #'class access' }
RMDGrammar >> disjunctionNodeClass [
	^ RMDDisjunctionNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> distanceDirective [
	^ ('distance' asPParser trimBlanks , _identifier)
		==>
			[ :pair | self distanceDirectiveNodeClass agent: pair second ]
]

{ #category : #'class access' }
RMDGrammar >> distanceDirectiveNodeClass [
	^ RMDDistanceDirectiveNode
]

{ #category : #'class access' }
RMDGrammar >> enUnitExpressionNodeClass [

	^ RMDEnUnitExpressionNode
]

{ #category : #units }
RMDGrammar >> energyUnits [
	^ {('J' -> #(1.0 nil 'J')).
	('kJ' -> #(1000.0 nil 'J')).
	('kcal' -> #(4184.0 nil 'J')).
	('cal' -> #(4.184 nil 'J'))} asDictionary
]

{ #category : #'parsers-expressions' }
RMDGrammar >> expr1 [

	^ ($( asPParser trimBlanks , self unit , $) asPParser trimBlanks
	   ==> #second) optional
	  , (_literal / ('-' asPParser trimBlanks optional
		    , (self parenExpression / self agentDirective / self apply
			     / self attributeVariable / self placeholder
			     / self utilityVariable / self metaVariable) ==> [ :pair | 
		    pair first
			    ifNil: [ pair second ]
			    ifNotNil: [ self unaryMinusNodeClass expression: pair second ] ]))
	  , ($[ asPParser trimBlanks , self unit , $] asPParser trimBlanks
		   ==> #second) optional ==> [ :triple | 
	  | expr |
	  expr := triple second.
	  triple first
		  ifNil: [ 
			  triple third
				  ifNil: [ expr ]
				  ifNotNil: [ :enUnit | 
				  self enUnitExpressionNodeClass expression: expr unit: enUnit ] ]
		  ifNotNil: [ :deUnit | 
			  triple third
				  ifNil: [ 
				  self deUnitExpressionNodeClass expression: expr unit: deUnit ]
				  ifNotNil: [ :enUnit | 
					  self deUnitExpressionNodeClass
						  expression:
						  (self enUnitExpressionNodeClass expression: expr unit: enUnit)
						  unit: deUnit ] ] ]
]

{ #category : #'parsers-expressions' }
RMDGrammar >> expr2 [
	^ (self expr1
		, (($^ asPParser trimBlanks , self int) ==> #second) optional)
		==> [ :pair | 
			pair second
				ifNil: [ pair first ]
				ifNotNil: [ self powerNodeClass expression: pair first order: pair second ] ]
]

{ #category : #'parsers-expressions' }
RMDGrammar >> expr4 [

	^ (self expr2 separatedBy:
		   ($* asPParser / $/ asPParser / $% asPParser) trimBlanks)
	  ==> [ :array |
		  (2 to: array size by: 2)
			  inject: array first
			  into: [ :total :index |
				  | op |
				  op := array at: index.
				  (op = $*
					   ifTrue: [ self productNodeClass ]
					   ifFalse: [
						   op = $/
							   ifTrue: [ self fractionNodeClass ]
							   ifFalse: [ self remainderNodeClass ] ])
					  expression: total
					  expression: (array at: index + 1) ] ]
]

{ #category : #'parsers-expressions' }
RMDGrammar >> expr5 [
	^ (self expr4 separatedBy: ($+ asPParser / $- asPParser) trimBlanks)
		==> [ :array | 
			(2 to: array size by: 2)
				inject: array first
				into: [ :total :index | 
					| op |
					op := array at: index.
					(op = $+
						ifTrue: [ self additionNodeClass ]
						ifFalse: [ self subtractionNodeClass ])
						expression: total
						expression: (array at: index + 1) ] ]
]

{ #category : #'parsers-expressions' }
RMDGrammar >> expr6 [

	^ self uniformDistribution / self normalDistribution
	  / self gammaDistribution / self logLogisticDistribution / self expr5
]

{ #category : #'parsers-expressions' }
RMDGrammar >> expression [

	^ _expression
]

{ #category : #'class access' }
RMDGrammar >> externalVariableNodeClass [
	^ RMDUtilityVariableNode
]

{ #category : #'class access' }
RMDGrammar >> fractionNodeClass [
	^ RMDFractionNode
]

{ #category : #'parsers-expressions' }
RMDGrammar >> gammaDistribution [

	^ 'gamma' asPParser trimBlanks , self expr5 , 'scale' asPParser trimBlanks
	  , self expr5 ==> [ :quad |
	  self gammaDistributionNodeClass
		  shape: quad second
		  scale: quad fourth ]
	  /
		  ('gamma' asPParser trimBlanks , self expr5
		   , 'rate' asPParser trimBlanks , self expr5 ==> [ :quad |
		   self gammaDistributionNodeClass
			   shape: quad second
			   rate: quad fourth ])
	  /
		  ('gamma' asPParser trimBlanks , self expr5
		   , 'mean' asPParser trimBlanks , self expr5 ==> [ :quad |
		   self gammaDistributionNodeClass
			   shape: quad second
			   mean: quad fourth ])
]

{ #category : #'class access' }
RMDGrammar >> gammaDistributionNodeClass [

	^ RMDGammaDistributionNode
]

{ #category : #'parsers-expressions' }
RMDGrammar >> guard [
	^ ('if ' asPParser trimBlanks , _condition , $, asPParser trimBlanks
		, #newline asPParser trimBlanks optional) ==> #second
]

{ #category : #'parsers-expressions' }
RMDGrammar >> guardedChoice [

	^ _guardedChoice
]

{ #category : #'class access' }
RMDGrammar >> guardedChoiceNodeClass [
	^ RMDGuardedChoiceNode
]

{ #category : #'parsers-atoms' }
RMDGrammar >> identifier [

	^ _identifier
]

{ #category : #'parsers-atoms' }
RMDGrammar >> int [

	^ $- asPParser optional , self nat
	  ==> [ :pair | 
	  (pair first ifNil: [ 1 ] ifNotNil: [ -1 ]) * pair second ]
]

{ #category : #'parsers-files' }
RMDGrammar >> interpolation [

	^ ('nearest' asPParser ==> [ :s | RMDDataInterpolation nearest ]
	   / ('latest' asPParser ==> [ :s | RMDDataInterpolation latest ])
	   / ('linear' asPParser ==> [ :s | RMDDataInterpolation linear ]))
		  trimBlanks
]

{ #category : #accessing }
RMDGrammar >> keywords [
	^ Keywords
		ifNil:
			[ Keywords := 'nearest distance direction delta is with if where become otherwise time my the'
				substrings asSet ]
]

{ #category : #'parsers-directives' }
RMDGrammar >> killDirective [

	^ 'kill' asPParser trimBlanks
	  ==> [ :die | self killDirectiveNodeClass new ]
]

{ #category : #'class access' }
RMDGrammar >> killDirectiveNodeClass [

	^ RMDKillDirectiveNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> lengthDirective [

	^ ('length' asPParser , #blank asPParser plus , 'of' asPParser
	   , #blank asPParser plus , 'here' asPParser) trimBlanks
	  ==> [ :array | self lengthDirectiveNodeClass new ]
]

{ #category : #'class access' }
RMDGrammar >> lengthDirectiveNodeClass [

	^ RMDLengthDirectiveNode
]

{ #category : #units }
RMDGrammar >> lengthUnits [
	^ {('km' -> #(1000.0 nil 'm')).
	('m' -> #(1.0 nil 'm')).
	('cm' -> #(0.01 nil 'm')).
	('mm' -> #(0.001 nil 'm'))} asDictionary
]

{ #category : #'parsers-directives' }
RMDGrammar >> lifeDirective [

	^ self dieDirective / self killDirective / self newDirective / self stageDirective
]

{ #category : #'parsers-atoms' }
RMDGrammar >> literal [

	^ _literal
]

{ #category : #'class access' }
RMDGrammar >> literalNodeClass [
	^ RMDLiteralNode
]

{ #category : #'parsers-variability' }
RMDGrammar >> literalSequence [

	^ _literal onlySeparatedBy: $, asPParser trimSpaces
]

{ #category : #'parsers-expressions' }
RMDGrammar >> logLogisticDistribution [

	^ ('loglogistic' asPParser / 'fisk' asPParser) trimBlanks , self expr5
	  , 'shape' asPParser trimBlanks , self expr5 ==> [ :quad |
	  self logLogisticDistributionNodeClass
		  scale: quad second
		  shape: quad fourth ]
]

{ #category : #'class access' }
RMDGrammar >> logLogisticDistributionNodeClass [

	^ RMDLogLogisticDistributionNode
]

{ #category : #'parsers-variability' }
RMDGrammar >> metaParameterSequence [

	^ self metaSingleParameterSequence / self metaParameterSetSequence
]

{ #category : #'parsers-variability' }
RMDGrammar >> metaParameterSetSequence [

	^ (self placeholder onlySeparatedBy: $, asPParser trimBlanks)
	  , '->' asPParser trimSpaces , self tupleSequence ==> [ :triple | 
	  | placeholders tupleSequence |
	  placeholders := triple first.
	  tupleSequence := triple third.
	  (tupleSequence allSatisfy: [ :tuple | 
		   placeholders size = tuple size ])
		  ifTrue: [ 
			  self metaParameterSetSequenceNodeClass
				  placeholders: placeholders
				  literalTuples: triple third ]
		  ifFalse: [ 
			  PP2Failure message:
				  'The size of each tuple should be equal to the number of parameters' ] ]
]

{ #category : #'class access' }
RMDGrammar >> metaParameterSetSequenceNodeClass [

	^ RMDMetaParameterSetSequenceNode
]

{ #category : #'parsers-variability' }
RMDGrammar >> metaSingleParameterSequence [

	^ self placeholder , '->' asPParser trimSpaces , self literalSequence
	  ==> [ :triple | 
		  self metaSingleParameterSequenceNodeClass
			  placeholder: triple first
			  literals: triple third ]
]

{ #category : #'class access' }
RMDGrammar >> metaSingleParameterSequenceNodeClass [

	^ RMDMetaSingleParameterSequenceNode
]

{ #category : #'parsers-atoms' }
RMDGrammar >> metaVariable [

	^ ('_' asPParser
	   , (#letter asPParser / #digit asPParser / $_ asPParser) star)
		  flatten
	  ==> [ :str | self utilityVariableNodeClass identifier: str ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> namely [

	^ 'namely' asPParser trimBlanks
]

{ #category : #'parsers-atoms' }
RMDGrammar >> nat [

	^ #digit asPParser plus
	  ==> [ :digits | 
	  digits inject: 0 into: [ :i :c | i * 10 + c digitValue ] ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> nearest [

	^ #blank asPParser , 'nearest' asPParser , #blank asPParser
]

{ #category : #'class access' }
RMDGrammar >> negationNodeClass [
	^ RMDNegationNode
]

{ #category : #'class access' }
RMDGrammar >> newAttributeVariableNodeClass [

	^ RMDNewAttributeVariableNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> newDirective [

	^ 'new' asPParser , #blank asPParser plus
	  , (_expression , _agentIdentifier
		   / ('-' asPParser trimBlanks ==> [ :minus | nil ]))
	  ==> [ :triple | 
		  triple third
			  ifNil: [ self newDirectiveNodeClass new ]
			  ifNotNil: [ :pair | 
				  self newDirectiveNodeClass
					  animatIdentifier: pair second
					  quantity: pair first ] ]
]

{ #category : #'class access' }
RMDGrammar >> newDirectiveNodeClass [

	^ RMDNewDirectiveNode
]

{ #category : #'parsers-expressions' }
RMDGrammar >> normalDistribution [

	^ 'normal' asPParser trimBlanks , self expr5
	  , 'sigma' asPParser trimBlanks , self expr5 ==> [ :quad |
	  self normalDistributionNodeClass
		  mean: quad second
		  sigma: quad fourth ]
]

{ #category : #'class access' }
RMDGrammar >> normalDistributionNodeClass [

	^ RMDNormalDistributionNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> numberOfIndividualsInPatchDirective [

	^ 'number' asPParser trimLeft , #blank asPParser plus
	  , 'of' asPParser , #blank asPParser plus ==> [ :array | nil ]
	  , _agentIdentifier , 'here' asPParser trimBlanks ==> [ :triple | 
	  self numberOfIndividualsInPatchDirectiveNodeClass animatName:
		  triple second ]
]

{ #category : #'class access' }
RMDGrammar >> numberOfIndividualsInPatchDirectiveNodeClass [
	^ RMDNumberOfIndividualsInPatchDirectiveNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> numberOfIndividualsInRadiusDirective [

	^ 'number' asPParser trimLeft , #blank asPParser plus
	  , 'of' asPParser , #blank asPParser plus ==> [ :array | nil ]
	  , _agentIdentifier , ('in' asPParser trimBlanks , _expression
	   , 'radius' asPParser trimBlanks ==> #second) ==> [ :triple |
	  self numberOfIndividualsInRadiusDirectiveNodeClass
		  animatName: triple second
		  radius: triple third ]
]

{ #category : #'class access' }
RMDGrammar >> numberOfIndividualsInRadiusDirectiveNodeClass [

	^ RMDNumberOfIndividualsInRadiusDirectiveNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> numberOfIndividualsInWorldDirective [

	^ 'number' asPParser trimLeft , #blank asPParser plus
	  , 'of' asPParser , #blank asPParser plus ==> [ :array | nil ]
	  , _agentIdentifier
	  ,
		  ('in' asPParser , #blank asPParser plus
		   , 'world' asPParser trimBlanks ==> [ :array | nil ])
	  ==> [ :triple | 
		  self numberOfIndividualsInWorldDirectiveNodeClass animatName:
			  triple second ]
]

{ #category : #'class access' }
RMDGrammar >> numberOfIndividualsInWorldDirectiveNodeClass [
	^ RMDNumberOfIndividualsInWorldDirectiveNode
]

{ #category : #'parsers-atoms' }
RMDGrammar >> numberString [

	^ self decimalString / self pi
]

{ #category : #'parsers-definitions' }
RMDGrammar >> parameterInstantiation [

	^ self placeholder , '->' asPParser trimBlanks
	  , (_condition / _expression)
	  /
	  (self newDirective , '->' asPParser trimBlanks , self newDirective)
	  /
	  (self stageDirective , '->' asPParser trimBlanks
	   , self stageDirective) ==> [ :triple | 
	  self parameterInstantiationNodeClass
		  placeholder: triple first
		  replacement: triple third ]
]

{ #category : #'class access' }
RMDGrammar >> parameterInstantiationNodeClass [
	^ RMDParameterInstantiationNode
]

{ #category : #'parsers-expressions' }
RMDGrammar >> parenExpression [
	^ ($( asPParser , _guardedChoice , $) asPParser) ==> #second
]

{ #category : #'parsers-visualizations' }
RMDGrammar >> patchColorAlphaRenderer [

	^ 'Patch' asPParser trimBlanks , '->' asPParser trimBlanks
	  , self color , 'with' asPParser trimBlanks
	  , 'alpha' asPParser trimBlanks
	  , 'proportional' asPParser trimBlanks , 'to' asPParser trimBlanks
	  , _expression , 'between' asPParser trimBlanks , _literal
	  , 'and' asPParser trimBlanks , _literal
	  , 'with' asPParser trimBlanks , self nat
	  , 'pixels' asPParser trimBlanks , self color
	  , 'grids' asPParser trimBlanks , '.' asPParser
	  , #newline asPParser trimBlanks optional ==> [ :array | 
	  (RMDPatchColorAlphaRenderer
		   color: (array at: 3)
		   alpha: (array at: 8)
		   between: (array at: 10)
		   and: (array at: 12))
		  borderWidth: (array at: 14);
		  borderColor: (array at: 16);
		  yourself ]
]

{ #category : #'parsers-visualizations' }
RMDGrammar >> patchColorBrightnessRenderer [

	^ 'Patch' asPParser trimBlanks , '->' asPParser trimBlanks
	  , self color , 'with' asPParser trimBlanks
	  , 'brightness' asPParser trimBlanks
	  , 'proportional' asPParser trimBlanks , 'to' asPParser trimBlanks
	  , _expression , 'between' asPParser trimBlanks , _literal
	  , 'and' asPParser trimBlanks , _literal
	  , 'with' asPParser trimBlanks , self nat
	  , 'pixels' asPParser trimBlanks , self color
	  , 'grids' asPParser trimBlanks , '.' asPParser
	  , #newline asPParser trimBlanks optional ==> [ :array | 
	  (RMDPatchColorBrightnessRenderer
		   color: (array at: 3)
		   brightness: (array at: 8)
		   between: (array at: 10)
		   and: (array at: 12))
		  borderWidth: (array at: 14);
		  borderColor: (array at: 16);
		  yourself ]
]

{ #category : #'parsers-visualizations' }
RMDGrammar >> patchColorMapRenderer [

	^ 'Patch' asPParser trimBlanks , '->' asPParser trimBlanks
	  , 'map' asPParser trimBlanks , _expression
	  , 'with' asPParser trimBlanks , #newline asPParser trimBlanks
	  ==> #fourth
	  ,
		  (self color , 'if' asPParser trimBlanks
		   , '>=' asPParser trimBlanks , self literal
		   , ',' asPParser trimBlanks , #newline asPParser
		   ==> [ :array | (array at: 4) -> (array at: 1) ]) star
	  , self color
	  , (#newline asPParser , 'with' asPParser trimBlanks , self nat
		   , 'pixels' asPParser trimBlanks ==> #third)
	  ,
	  (self color , 'grids' asPParser trimBlanks , '.' asPParser
	   ==> #first) , #newline asPParser optional ==> [ :array | 
	  | renderer |
	  renderer := RMDPatchColorMapRenderer
		              expression: (array at: 1)
		              color: (array at: 3).
	  (array at: 2) do: [ :assoc | 
		  renderer add: assoc value at: assoc key ].
	  renderer
		  borderWidth: (array at: 4);
		  borderColor: (array at: 5).
	  renderer ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> patchDefinition [

	^ _patchDefinition
]

{ #category : #'class access' }
RMDGrammar >> patchDefinitionNodeClass [
	^ RMDPatchDefinitionNode
]

{ #category : #'parsers-definitions' }
RMDGrammar >> patchInitializer [

	^ #digit asPParser plus flatten trimBlanks , 'x' asPParser
	  , #digit asPParser plus flatten trimBlanks
	  , 'of' asPParser trimBlanks , _literal
	  , 'Patch' asPParser trimBlanks
	  , ('with' asPParser , #newline asPParser trimBlanks
		   , (self attributeInitializer onlySeparatedBy:
				    #newline asPParser trimBlanks) ==> #last) optional
	  , self whereClause optional ==> [ :array | 
	  self patchInitializerNodeClass
		  xDivisions: array first asInteger
		  yDivisions: array third asInteger
		  length: array fifth
		  patchAttributeInitializers: (array seventh ifNil: [ Array new ])
		  utilityDefinitions: (array eighth ifNil: [ Array new ]) ]
]

{ #category : #'class access' }
RMDGrammar >> patchInitializerNodeClass [
	^ RMDPatchInitializerNode
]

{ #category : #'parsers-atoms' }
RMDGrammar >> pi [

	^ $- asPParser trimBlanks optional
	  , ('π' asPParser / 'pi' asPParser) trimBlanks
	  ==> [ :pair | (pair first ifNil: [ '' ] ifNotNil: [ '-' ]) , 'π' ]
]

{ #category : #'parsers-atoms' }
RMDGrammar >> placeholder [

	^ 'the' asPParser , #blank asPParser plus , _identifier
	  ==> [ :triple | 
	  self placeholderNodeClass identifier: triple third ]
]

{ #category : #'class access' }
RMDGrammar >> placeholderNodeClass [
	^ RMDPlaceholderNode
]

{ #category : #'class access' }
RMDGrammar >> powerNodeClass [
	^ RMDPowerNode
]

{ #category : #'class access' }
RMDGrammar >> productNodeClass [
	^ RMDProductNode
]

{ #category : #'class access' }
RMDGrammar >> remainderNodeClass [

	^ RMDRemainderNode
]

{ #category : #'parsers-visualizations' }
RMDGrammar >> renderer [

	^ self animatDotRenderer / self animatRectangleRenderer
	  / self animatTriangleRenderer / self animatIconRenderer
	  / self backgroundColorRenderer / self patchColorAlphaRenderer
	  / self patchColorBrightnessRenderer / self patchColorMapRenderer
]

{ #category : #'parsers-definitions' }
RMDGrammar >> simulationDefinition [
	^ (('Simulation' asPParser trimBlanks , 'with' asPParser
		, #newline asPParser trimBlanks) ==> [ :triple | nil ]
		,
			((self simulationTimeDefinition , #newline asPParser trimBlanks optional)
				==> #first) , self worldInitializer optional
		, ((self patchInitializer , #newline asPParser trimBlanks optional) ==> #first)
		,
			(self animatInitializer onlySeparatedBy: #newline asPParser trimBlanks) optional
		, '.' asPParser trimBlanks , #newline asPParser trimBlanks optional)
		==> [ :array | 
			self simulationDefinitionNodeClass
				timeDefinition: array second
				worldInitializer: array third
				patchInitializer: array fourth
				animatInitializers: (array fifth ifNil: [ { } ]) ]
]

{ #category : #'class access' }
RMDGrammar >> simulationDefinitionNodeClass [
	^ RMDSimulationDefinitionNode
]

{ #category : #'parsers-files' }
RMDGrammar >> simulationFile [

	^ self simulationDefinition ==> [ :simulation | 
	  self simulationFileNodeClass simulationDefinition: simulation ]
]

{ #category : #'class access' }
RMDGrammar >> simulationFileNodeClass [

	^ RMDSimulationFileNode
]

{ #category : #'parsers-definitions' }
RMDGrammar >> simulationTimeDefinition [
	^ (('during' asPParser trimBlanks , _literal) ==> #last
		,
			(('step' asPParser trimBlanks optional , 'by' asPParser trimBlanks
				, _literal) ==> #last))
		==> [ :pair | 
			self simulationTimeDefinitionNodeClass
				duration: pair first
				step: pair second ]
]

{ #category : #'class access' }
RMDGrammar >> simulationTimeDefinitionNodeClass [
	^ RMDSimulationTimeDefinitionNode
]

{ #category : #'parsers-directives' }
RMDGrammar >> stageDirective [

	^ 'stage' asPParser , #blank asPParser plus
	  ,
	  (_agentIdentifier / ('-' asPParser trimBlanks ==> [ :minus | nil ]))
	  ==> [ :triple | 
		  self stageDirectiveNodeClass animatIdentifier: triple third ]
]

{ #category : #'class access' }
RMDGrammar >> stageDirectiveNodeClass [

	^ RMDStageDirectiveNode
]

{ #category : #accessing }
RMDGrammar >> start [
	"Answer the production to start this parser with."
	
	self definition
]

{ #category : #'class access' }
RMDGrammar >> subtractionNodeClass [
	^ RMDSubtractionNode
]

{ #category : #'parsers-definitions' }
RMDGrammar >> taskDefinition [

	^ _taskDefinition
]

{ #category : #'parsers-definitions' }
RMDGrammar >> taskDefinitionHeader [

	^ self taskDefinitionHeaderWithNamely
	  / self taskDefinitionHeaderWithoutNamely
]

{ #category : #'parsers-definitions' }
RMDGrammar >> taskDefinitionHeaderWithNamely [

	^ _agentIdentifier , _identifier
	  ,
	  (self nearest optional , _agentIdentifier , self withinClause)
		  optional , self namely , self actionIdentifier ==> [ :array | 
	  | subject verb nearest object range action |
	  subject := array first.
	  verb := array second.
	  nearest := (array third ifNotNil: #first) notNil.
	  object := array third ifNotNil: #second.
	  range := array third ifNotNil: #third.
	  action := array fifth.
	  { 
		  subject.
		  verb.
		  nearest.
		  object.
		  range.
		  action } ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> taskDefinitionHeaderWithoutNamely [

	^ _agentIdentifier , self actionIdentifier
	  ,
	  (self nearest optional , _agentIdentifier , self withinClause)
		  optional ==> [ :triple | 
	  | subject verb nearest object range action |
	  subject := triple first.
	  verb := triple second.
	  nearest := (triple third ifNotNil: #first) notNil.
	  object := triple third ifNotNil: #second.
	  range := triple third ifNotNil: #third.
	  action := triple second.
	  { 
		  subject.
		  verb.
		  nearest.
		  object.
		  range.
		  action } ]
]

{ #category : #'parsers-files' }
RMDGrammar >> tasksFile [

	^ self taskDefinition star
	  ==> [ :tasks | self tasksFileNodeClass tasks: tasks ]
]

{ #category : #'class access' }
RMDGrammar >> tasksFileNodeClass [

	^ RMDTasksFileNode
]

{ #category : #units }
RMDGrammar >> temperatureUnits [
	^ {('K' -> #(1.0 nil 'K')).
	('C' -> #(1.0 273.15 'K')).
	('F' -> #(0.5555555555555556 255.3722222222222 'J'))} asDictionary
]

{ #category : #'parsers-atoms' }
RMDGrammar >> the [

	^ 'the' asPParser ==> [ :the | #the ] , #blank asPParser plus
	  ==> #first
]

{ #category : #'parsers-directives' }
RMDGrammar >> timeDirective [

	^ self delta optional , 'time' asPParser trimBlanks ==> [ :pair | 
	  pair first
		  ifNil: [ self timeDirectiveNodeClass new ]
		  ifNotNil: [ self deltaTimeDirectiveNodeClass new ] ]
]

{ #category : #'class access' }
RMDGrammar >> timeDirectiveNodeClass [
	^ RMDTimeDirectiveNode
]

{ #category : #units }
RMDGrammar >> timeUnits [
	^ {('ms' -> #(0.001 nil 's')).
	('s' -> #(1.0 nil 's')).
	('min' -> #(60.0 nil 's')).
	('h' -> #(3600.0 nil 's')).
	('day' -> #(86400.0 nil 's'))} asDictionary
]

{ #category : #'parsers-variability' }
RMDGrammar >> tupleSequence [

	^ $( asPParser trimBlanks
	  , (_literal onlySeparatedBy: $, asPParser trimBlanks)
	  , $) asPParser trimBlanks ==> #second onlySeparatedBy:
		  $, asPParser trimSpaces
]

{ #category : #'parsers-units' }
RMDGrammar >> type [

	^ $[ asPParser trimBlanks , self unit optional
	  , $] asPParser trimBlanks
	  ==> [ :triple | triple second ifNil: [ RMDUnit noDimension ] ]
]

{ #category : #'class access' }
RMDGrammar >> unaryMinusNodeClass [
	^ RMDUnaryMinusNode
]

{ #category : #'parsers-expressions' }
RMDGrammar >> uniformDistribution [

	^ 'uniform_integer' asPParser trimBlanks , self expr5
	  , 'to' asPParser trimBlanks , self expr5 ==> [ :quad |
	  self uniformIntegerDistributionNodeClass
		  from: quad second
		  to: quad fourth ]
	  /
		  ('uniform' asPParser trimBlanks , self expr5
		   , 'to' asPParser trimBlanks , self expr5 ==> [ :quad |
		   self uniformDistributionNodeClass
			   from: quad second
			   to: quad fourth ])
]

{ #category : #'class access' }
RMDGrammar >> uniformDistributionNodeClass [
	^ RMDUniformDistributionNode
]

{ #category : #'class access' }
RMDGrammar >> uniformIntegerDistributionNodeClass [

	^ RMDUniformIntegerDistributionNode
]

{ #category : #'parsers-units' }
RMDGrammar >> unit [

	^ _unit
]

{ #category : #'parsers-units' }
RMDGrammar >> unitFactor [
	^ (self unitSymbol
		,
			(($^ asPParser
				,
					(($- asPParser optional , #digit asPParser)
						==> [ :pair | 
							pair second asString asInteger
								* (pair first ifNil: [ 1 ] ifNotNil: [ -1 ]) ])) ==> #second)
				optional)
		==> [ :pair | 
			pair second
				ifNotNil: [ pair first ** pair second ]
				ifNil: [ pair first ] ]
]

{ #category : #'parsers-units' }
RMDGrammar >> unitSymbol [

	^ ((#space asPParser / $/ asPParser / $] asPParser / $) asPParser
	    / $^ asPParser / $* asPParser) not , #any asPParser) plus flatten
	  ==> [ :symbol | 
		  RMDUnitSymbol
			  at: symbol
			  ifAbsent: [ PP2Failure message: 'Unknown unit symbol: ' , symbol ] ]
]

{ #category : #'parsers-units' }
RMDGrammar >> unitTerm [

	^ (self unitFactor onlySeparatedBy:
		   #blank asPParser plus / $• asPParser / $* asPParser)
	  ==> [ :array | 
		  array inject: RMDUnit noDimension into: [ :unit :f | unit * f ] ]
	  / ('1' asPParser trimBlanks ==> [ :one | RMDUnit noDimension ])
]

{ #category : #'parsers-definitions' }
RMDGrammar >> utilityDefinition [
	^ (self utilityVariable , '=' asPParser trimBlanks , _guardedChoice)
		==> [ :triple | 
			self utilityDefinitionNodeClass
				variable: triple first
				expression: triple third ]
]

{ #category : #'class access' }
RMDGrammar >> utilityDefinitionNodeClass [
	^ RMDUtilityDefinitionNode
]

{ #category : #'parsers-atoms' }
RMDGrammar >> utilityVariable [
	^ _identifier
		==> [ :str | self utilityVariableNodeClass identifier: str ]
]

{ #category : #'class access' }
RMDGrammar >> utilityVariableNodeClass [
	^ RMDUtilityVariableNode
]

{ #category : #'parsers-variability' }
RMDGrammar >> variability [

	^ 'Variability' asPParser trimBlanks , ('with' asPParser
	   ,
		   (#newline asPParser trimBlanks , 'reproduce' asPParser trimBlanks
		    , 'random' asPParser trimBlanks , self nat
		    ==> [ :quad | #random -> quad fourth ]
		    / (#newline asPParser trimBlanks , self nat
			     , 'runs' asPParser trimBlanks , 'each' asPParser trimBlanks
			     ==> [ :quad | #multiplicity -> quad second ])) optional
	   , (#newline asPParser trimBlanks
		    , (self metaParameterSequence onlySeparatedBy:
				     #newline asPParser trimBlanks) ==> #second) optional)
		  optional , '.' asPParser trimBlanks ==> #second ==> [ :triple | 
	  triple ifNil: [ self variabilityNodeClass new ] ifNotNil: [ 
		  triple second
			  ifNil: [ 
				  self variabilityNodeClass
					  multiplicity: 1
					  metaParameterSequences: (triple third ifNil: [ #(  ) ]) ]
			  ifNotNil: [ 
				  triple second key = #random
					  ifTrue: [ 
						  self variabilityNodeClass
							  random: triple second value
							  metaParameterSequences: (triple third ifNil: [ #(  ) ]) ]
					  ifFalse: [ 
						  self variabilityNodeClass
							  multiplicity: triple second value
							  metaParameterSequences: (triple third ifNil: [ #(  ) ]) ] ] ] ]
]

{ #category : #'class access' }
RMDGrammar >> variabilityNodeClass [

	^ RMDVariabilityNode
]

{ #category : #'parsers-files' }
RMDGrammar >> visualizationFile [

	^ self renderer star
	  ==> [ :renderers | 
	  self visualizationFileNodeClass renderers: renderers ]
]

{ #category : #'class access' }
RMDGrammar >> visualizationFileNodeClass [

	^ RMDVisualizationFileNode
]

{ #category : #units }
RMDGrammar >> weightUnits [
	^ {('t' -> #(1000 nil 'kg')).
	('kg' -> #(1 nil 'kg')).
	('g' -> #(0.001 nil 'kg')).
	('mg' -> #(0.000001 nil 'kg'))} asDictionary
]

{ #category : #'parsers-definitions' }
RMDGrammar >> whenClause [

	^ #newline asPParser trimBlanks , 'when' asPParser trimBlanks
	  , _condition ==> #third
]

{ #category : #'parsers-definitions' }
RMDGrammar >> whereClause [

	^ #newline asPParser trimBlanks optional
	  , 'where' asPParser trimBlanks , #newline asPParser trimBlanks
	  ,
	  (self utilityDefinition onlySeparatedBy:
		   #newline asPParser trimBlanks)
	  , #newline asPParser trimBlanks optional ==> #fourth
]

{ #category : #'parsers-definitions' }
RMDGrammar >> withAttributeClause [
	^ ('with' asPParser trimBlanks , #newline asPParser trimBlanks
		,
			(self attributeDeclaration
				onlySeparatedBy: #newline asPParser trimBlanks)
		, #newline asPParser trimBlanks optional) ==> #third
]

{ #category : #'parsers-definitions' }
RMDGrammar >> withDirectiveClause [

	^ #newline asPParser trimBlanks , 'with' asPParser trimBlanks
	  , (self lifeDirective separatedBy: ',' asPParser trimBlanks)
	  ==> [ :triple | 
		  | array |
		  array := triple third.
		  (1 to: array size by: 2) collect: [ :index | array at: index ] ]
]

{ #category : #'parsers-definitions' }
RMDGrammar >> withinClause [

	^ 'within' asPParser trimBlanks , _literal ==> #second
]

{ #category : #'parsers-definitions' }
RMDGrammar >> worldDefinition [

	^ _worldDefinition
]

{ #category : #'class access' }
RMDGrammar >> worldDefinitionNodeClass [
	^ RMDWorldDefinitionNode
]

{ #category : #'parsers-definitions' }
RMDGrammar >> worldInitializer [

	^ 'World' asPParser trimBlanks
	  , ('with' asPParser trimBlanks , #newline asPParser trimBlanks
		   , (self attributeInitializer onlySeparatedBy:
				    #newline asPParser trimBlanks) ==> #third) optional
	  , self whereClause optional
	  , #newline asPParser trimBlanks optional ==> [ :quad | 
	  self worldInitializerNodeClass
		  attributeInitializers: (quad second ifNil: [ Array new ])
		  utilityDefinitions: (quad third ifNil: [ Array new ]) ]
]

{ #category : #'class access' }
RMDGrammar >> worldInitializerNodeClass [
	^ RMDWorldInitializerNode
]
