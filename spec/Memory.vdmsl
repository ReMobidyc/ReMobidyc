module Memory
exports all
definitions
types
     Address = nat1;

values
     ADDRESS_ERROR = <ADDRESS_ERROR>;

state Memory of
    vals : map Address to real
    next : map Address to real
    delta : map Address to real
    storage : seq of (map Address to real)
    ticks : nat
init s == s = mk_Memory({|->}, {|->}, {|->}, [], 0)
end

operations
    read : Address ==> real
    read(address) ==
        if address in set dom vals then return vals(address) else exit ADDRESS_ERROR;
    
    write : Address * real ==> ()
    write(address, data) ==
        if address in set dom next then next(address) := data else exit ADDRESS_ERROR;
    
    writeDelta : Address * real ==> ()
    writeDelta(address, data) ==
        if
            address in set dom delta
        then
            delta(address) := delta(address) + data
        else
            exit ADDRESS_ERROR;
    
    setTime : nat ==> ()
    setTime(t) ==
        (if
            t = 0
        then
            (vals := {|->};
            delta := {|->};
            ticks := 0;
            return );
        ticks := t;
        if
            ticks = len storage + 1
        then
            storage
                := storage ^ [{a |-> next(a) + delta(a) | a in set dom next}];
        if ticks > len storage + 1 then exit <INVALID_TIME>;
        vals := storage(ticks);
        next := vals;
        delta := {a |-> 0 | a in set dom vals};
        return );
    
    getTime : () ==> nat
    getTime() == return ticks;
    
    tick : () ==> ()
    tick() == setTime(getTime() + 1);

end Memory
