module Interpreter
imports
    from AST all,
    from Unit all,
    from Utilities functions pow: real * int -> real renamed pow;,
    from Random all,
    from MATH
        functions
            ln renamed ln;
            sqrt renamed sqrt;
            cos renamed cos;
exports functions eval : AST`Expression -> real;


		/*** distributions ***/
definitions
types
     Context :: random : Random`RandomGenerator;

functions
    eval : AST`Expression -> real
    eval(expr) ==
        cases expr:
            mk_AST`Literal(val, unit) -> Unit`toSI(unit, val),
            mk_AST`Addition(expr1, expr2) -> eval(expr1) + eval(expr2),
            mk_AST`Subtraction(expr1, expr2) -> eval(expr1) - eval(expr2),
            mk_AST`Product(expr1, expr2) -> eval(expr1)  * eval(expr2),
            mk_AST`Fraction(expr1, expr2) -> eval(expr1) / eval(expr2),
            mk_AST`Power(expr, order) -> pow(eval(expr), order),
            mk_AST`Minus(expr) -> -eval(expr),
            mk_AST`DeUnitCasting(unit, expr) -> Unit`fromSI(unit, eval(expr)),
            mk_AST`EnUnitCasting(expr, unit) -> Unit`toSI(unit, eval(expr))
            end;
    
    uniform : real * real * real -> real
    uniform(sectionFrom, sectionTo, x) ==
        x  * (sectionTo - sectionFrom) + sectionFrom
    pre isUnit(x);
    
    normal : real * real * real * real -> real
    normal(mean, sigma, x1, x2) ==
        sqrt(ln(x1)  * -2.0)  * cos(x2  * 3.141592653589793  * 2.0)  * sigma
        + mean
    pre isUnit(x1) and isUnit(x2);
    
    isUnit : real -> bool
    isUnit(x) == x >= 0 and x <= 1;
		
/*
     Expression =
        Variable| Apply| GuardedChoices|
        Placeholder;
     GuardedChoices :: seq1 of (Condition * Expression) Expression;
	-- atoms
     Variable =
        AttributeVariable| NewAttributeVariable| UtilityVariable;
     AttributeVariable :: agent : [Identifier] identifier : Identifier;
     NewAttributeVariable :: identifier : Identifier;
     UtilityVariable :: identifier : Identifier;

	-- composite
     Apply :: function : Identifier arguments : seq1 of Expression;
   -- randoms
     UniformDistribution ::
        beginSection : Expression endSection : Expression;
     NormalDistribution :: mean : Expression sigma : Expression;
     GammaDistribution :: shape : Expression scale : Expression;
     LogLogisticDistribution :: scale : Expression shape : Expression;
	-- directives
     Directive = AgentDirective| PatchDirective;
     AgentDirective ::
        <direction>| <distance>| <time>| <deltatime> agent : [Identifier];
     PatchDirective :: <gradient> Identifier;
*/

state Interpreter of
    context : Context
init s == s = mk_Interpreter(mk_Context(mk_Random`RandomGenerator(1)))
end

operations
    random : () ==> real
    random() ==
        (context .random := Random`next(context.random);
        return Random`value(context.random));

end Interpreter
