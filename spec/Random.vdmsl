module Random
exports all
definitions
types
     RandomGenerator :: seed : nat;

values
     factor : nat = 742938285;
     modulo : nat = 2147483647;

functions
    value : Random`RandomGenerator -> real
    value(mk_Random`RandomGenerator(seed)) ==
        (seed - 1) / (modulo - 1);
    
    next : Random`RandomGenerator -> Random`RandomGenerator
    next(mk_Random`RandomGenerator(seed)) ==
        mk_Random`RandomGenerator(seed  * factor mod modulo);
    
    hash : seq1 of nat1 -> nat1
    hash(seeds) ==
        let
            calcSeed : nat1 * seq of nat1 -> nat1
            calcSeed(x, ys) ==
                cases ys:
                    [z]^zs -> calcSeed((x + z)  * factor mod modulo, zs),
                    others -> x  * factor mod modulo
                    end
        in calcSeed(hd seeds, tl seeds);

end Random
