module AST
exports all
definitions
types
     SimulationModel ::
        simulationDefinition : AST`SimulationDefinition
        animatDefinitions : map AST`Identifier to AST`AnimatDefinition
        worldDefinition : AST`WorldDefinition
        patchDefinition : AST`PatchDefinition
        actionDefinitions : map AST`Identifier to AST`ActionDefinition
        taskDefinitions : seq of AST`TaskDefinition;
     SimulationDefinition ::
        timeDefinition : SimulationTimeDefinition
        worldInitializer : WorldInitializer
        patchInitializer : PatchInitializer
        animatInitializers : seq of AnimatInitializer;
     SimulationTimeDefinition :: timeDuration : Literal timeStep : Literal;
     AnimatDefinition ::
        identifier : AgentIdentifier
        species : AgentIdentifier
        attributeDeclarations : seq of AttributeDeclaration;
     PatchDefinition ::
        attributeDeclarations : seq of AttributeDeclaration;
     WorldDefinition ::
        attributeDeclarations : seq of AttributeDeclaration;
     AgentDefinition =
        AnimatDefinition| PatchDefinition| WorldDefinition;
     AttributeDeclaration :: identifier : Identifier unit : Unit;
     ActionDefinition ::
        identifier : Identifier
        object : [AgentIdentifier]
        guard : [Expression]
        lifeDirectives : seq of LifeDirective
        attributeDefinitions : seq of AttributeDefinition
        utilityDefinitions : seq of UtilityDefinition;
     TaskDefinition ::
        subjectIdentifier : AgentIdentifier
        verbIdentifier : Identifier
        objectIdentifier : [AgentIdentifier]
        nearest : bool
        range : Expression
        actionIdentifier : Identifier
        replacements : seq of Replacement;
     Replacement ::
        placeholder : Placeholder| DirectivePlaceholder
        replacement : Expression| Condition| NewDirective| StageDirective;
     LifeDirective =
        DieDirective| KillDirective| NewDirective| StageDirective|
        DirectivePlaceholder;
     DieDirective = <die>;
     KillDirective = <kill>;
     NewDirective :: stage : AgentIdentifier quantity : nat1;
     StageDirective :: stage : AgentIdentifier;
     DirectivePlaceholder =
        NewDirectivePlaceholder| StageDirectivePlaceholder;
     NewDirectivePlaceholder = <new>;
     StageDirectivePlaceholder = <stage>;
     AttributeDefinition ::
        variable : AssignableVariable expression : Expression;
     UtilityDefinition :: identifier : Identifier expression : Expression;
     AssignableVariable =
        AssignableAttributeVariable| AssignableDeltaAttributeVariable|
        AssignableDifferentialAttributeVariable;
     AssignableAttributeVariable ::
        attributeVariable : AttributeVariable| Placeholder;
     AssignableDeltaAttributeVariable ::
        attributeVariable : AttributeVariable| Placeholder;
     AssignableDifferentialAttributeVariable ::
        attributeVariable : AttributeVariable| Placeholder;
     AttributeBind ::
        placeholder : Placeholder| DirectivePlaceholder
        replacement : Expression;
     Placeholder :: identifier : Identifier;
     AnimatInitializer ::
        animat : AgentIdentifier
        population : nat1
        attributeInitializers : seq of AttributeInitializer;
     PatchInitializer ::
        xDivisions : nat1
        yDivisions : nat1
        size : Literal
        attributeInitializers : seq of AttributeInitializer;
     WorldInitializer ::
        attributeInitializers : seq of AttributeInitializer;
     AttributeInitializer ::
        identifier : Identifier expression : Expression;
     Expression =
        Variable| Literal| Casting| Apply| Arithmetics| Distribution|
        GuardedChoices| Directive| Placeholder;
     Variable =
        AttributeVariable| NewAttributeVariable| UtilityVariable;
     AttributeVariable :: agent : [Identifier] identifier : Identifier;
     NewAttributeVariable :: identifier : Identifier;
     UtilityVariable :: identifier : Identifier;
     Literal :: val : real unit : Unit;
     GuardedChoices :: seq1 of (Condition * Expression) Expression;
     Apply :: function : Identifier arguments : seq1 of Expression;
     Arithmetics =
        Addition| Subtraction| Product| Fraction| Power| Minus;
     Addition :: Expression Expression;
     Subtraction :: Expression Expression;
     Product :: Expression Expression;
     Fraction :: Expression Expression;
     Power :: Expression int;
     Minus :: Expression;
     Distribution =
        UniformDistribution| UniformDistributionX| UniformDistributionY|
        NormalDistribution| GammaDistribution| LogLogisticDistribution;
     UniformDistribution ::
        beginSection : Expression endSection : Expression;
     UniformDistributionX = <uniform_distribution_x>;
     UniformDistributionY = <uniform_distribution_y>;
     NormalDistribution :: mean : Expression sigma : Expression;
     GammaDistribution :: shape : Expression scale : Expression;
     LogLogisticDistribution :: scale : Expression shape : Expression;
     Directive = AgentDirective| PatchDirective;
     AgentDirective ::
        <direction>| <distance>| <time>| <delta_time> agent : [Identifier];
     PatchDirective :: <direction_of_gradient> Identifier;
     Casting = DeUnitCasting| EnUnitCasting;
     DeUnitCasting :: Unit Expression;
     EnUnitCasting :: Expression Unit;
     Unit :: seq of (SIBaseUnit * int) scale : real
        inv mk_Unit(us, -) ==
            card {u | mk_(u, -) in seq us} = len us
            and (forall mk_(-, o) in set elems us & o <> 0);
     SIBaseUnit = <kg>| <m>| <s>| <℃>| <K>| <℉>| <rad>| <mol>;
     Condition =
        Equality| GreaterOrEqual| GreaterThan| LessOrEqual| LessThan|
        NotEqual| Negation| Conjunction| Disjunction| Placeholder;
     Equality :: seq1 of Expression
        inv mk_Equality(exprs) == len exprs >= 2;
     GreaterOrEqual :: seq1 of Expression
        inv mk_GreaterOrEqual(exprs) == len exprs >= 2;
     GreaterThan :: seq1 of Expression
        inv mk_GreaterThan(exprs) == len exprs >= 2;
     LessOrEqual :: seq1 of Expression
        inv mk_LessOrEqual(exprs) == len exprs >= 2;
     LessThan :: seq1 of Expression
        inv mk_LessThan(exprs) == len exprs >= 2;
     NotEqual :: Expression Expression;
     Negation :: Condition;
     Conjunction :: seq1 of Condition
        inv mk_Conjunction(conds) == len conds >= 2;
     Disjunction :: seq1 of Condition
        inv mk_Disjunction(conds) == len conds >= 2;
     Identifier = seq of char;
     AgentIdentifier = seq of char;

types
     ReplacementMap =
        map (Placeholder| DirectivePlaceholder) to (Expression| Condition| NewDirective| StageDirective);
     ReplacementAST =
        Placeholder| DirectivePlaceholder| NewDirective| StageDirective|
        ActionDefinition| Expression| Condition| AttributeDefinition|
        UtilityDefinition| AssignableVariable;

functions
    replace : ReplacementAST * ReplacementMap -> ReplacementAST
    replace(ast, replacement) ==
        if
            ast in set dom replacement
        then
            replacement(ast)
        else
            cases ast:
                mk_AST`ActionDefinition(
                    identifier,
                    object,
                    guard,
                    lifeDirectives,
                    attributeDefinitions,
                    utilityDefinitions) ->
                    mk_AST`ActionDefinition(
                        identifier,
                        object,
                        replace(guard, replacement),
                        [replace(directive, replacement) | directive in seq lifeDirectives],
                        [replace(attrDef, replacement)
                            | attrDef in seq attributeDefinitions],
                        [replace(utilDef, replacement) | utilDef in seq utilityDefinitions]),
                mk_AST`AttributeDefinition(var, exp) ->
                    mk_AST`AttributeDefinition(replace(var, replacement), replace(exp, replacement)),
                mk_AST`UtilityDefinition(ident, exp) ->
                    mk_AST`UtilityDefinition(ident, replace(exp, replacement)),
                mk_AST`AssignableAttributeVariable(var) ->
                    mk_AST`AssignableAttributeVariable(replace(var, replacement)),
                mk_AST`AssignableDeltaAttributeVariable(var) ->
                    mk_AST`AssignableDeltaAttributeVariable(replace(var, replacement)),
                mk_AST`AssignableDifferentialAttributeVariable(var) ->
                    mk_AST`AssignableDifferentialAttributeVariable(replace(var, replacement)),
                others -> ast
                end;
    
    replaceExpression : Expression * ReplacementMap -> Expression
    replaceExpression(expression, replacement) ==
        if
            expression in set dom replacement
        then
            replacement(expression)
        else
            cases expression:
                mk_AST`GuardedChoices(conditionExpressionPairs, defaultExpression) ->
                    mk_AST`GuardedChoices(
                        [mk_(
                            replaceCondition(cond, replacement),
                            replaceExpression(expr, replacement))
                            | mk_(cond, expr) in seq conditionExpressionPairs],
                        replaceExpression(defaultExpression, replacement)),
                mk_AST`Apply(function, arguments) ->
                    mk_AST`Apply(
                        function,
                        [replaceExpression(arg, replacement) | arg in seq arguments]),
                mk_AST`Addition(expr1, expr2) ->
                    mk_AST`Addition(
                        replaceExpression(expr1, replacement),
                        replaceExpression(expr2, replacement)),
                mk_AST`Subtraction(expr1, expr2) ->
                    mk_AST`Subtraction(
                        replaceExpression(expr1, replacement),
                        replaceExpression(expr2, replacement)),
                mk_AST`Product(expr1, expr2) ->
                    mk_AST`Product(
                        replaceExpression(expr1, replacement),
                        replaceExpression(expr2, replacement)),
                mk_AST`Fraction(expr1, expr2) ->
                    mk_AST`Fraction(
                        replaceExpression(expr1, replacement),
                        replaceExpression(expr2, replacement)),
                mk_AST`Power(expr1, order) ->
                    mk_AST`Power(replaceExpression(expr1, replacement), order),
                mk_AST`Minus(expr) ->
                    mk_AST`Minus(replaceExpression(expr, replacement)),
                others -> expression
                end;
    
    replaceCondition : Condition * ReplacementMap -> Condition
    replaceCondition(condition, replacement) ==
        if
            condition in set dom replacement
        then
            replacement(condition)
        else
            cases condition:
                mk_AST`Equality(exprs) ->
                    mk_AST`Equality([replaceExpression(expr, replacement) | expr in seq exprs]),
                mk_AST`GreaterOrEqual(exprs) ->
                    mk_AST`GreaterOrEqual([replaceExpression(expr, replacement) | expr in seq exprs]),
                mk_AST`GreaterThan(exprs) ->
                    mk_AST`GreaterThan([replaceExpression(expr, replacement) | expr in seq exprs]),
                mk_AST`LessOrEqual(exprs) ->
                    mk_AST`LessOrEqual([replaceExpression(expr, replacement) | expr in seq exprs]),
                mk_AST`LessThan(exprs) ->
                    mk_AST`LessThan([replaceExpression(expr, replacement) | expr in seq exprs]),
                mk_AST`NotEqual(expr1, expr2) ->
                    mk_AST`NotEqual(
                        replaceExpression(expr1, replacement),
                        replaceExpression(expr2, replacement)),
                mk_AST`Negation(cond) ->
                    mk_AST`Negation(replace(cond, replacement)),
                mk_AST`Conjunction(conds) ->
                    mk_AST`Conjunction([replaceCondition(cond, replacement) | cond in seq conds]),
                mk_AST`Disjunction(conds) ->
                    mk_AST`Disjunction([replaceCondition(cond, replacement) | cond in seq conds]),
                others -> condition
                end;

end AST
